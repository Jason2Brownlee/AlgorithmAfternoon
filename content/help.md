# Help

Implementing algorithms can be challenging at times. This page offers some help.

## Coding Tips

* Use your favorite programming language. Python is popular, why not start there?
* Get to know the pseudo-random number generator library in your programming language. You will use it a lot.
* Apply the algorithm to a standard test problem. Don't reinvent the wheel, there are hundreds of test problems to choose from (e.g. [function optimization](https://en.wikipedia.org/wiki/Test_functions_for_optimization)).
* Split behaviors into sub-functions and unit test each. Often these algorithms will "work" despite bugs, just not the way you intended.
* Get something "working" first, then make it "correct". This might mean substituting complex behaviors and functions for simple functions initially.
* Develop a "slow version" first, then make it "fast". This might mean using pure Python before migrating to numpy.
* The rabbit hole goes deep. Each algorithm is actually a tiny universe of research papers, book chapters, theses, academics, code libraries, etc. Some algorithms are more coherent than others, and this is part of the fun.
* Relax your notion of "correct". Each algorithm rarely has a canonical definition to the level of detail we might demand of bubble sort or depth-first search. Instead algorithms may have  many variations, often slightly different in each paper and library. Embrace the diversity, parametrize the differences.
* Code the algorithms yourself, it's more fun. Avoid generating or copy-pasting from elsewhere if you can.
* Build up your own personal library of algorithm implementations (e.g. on github, gitlab, etc.). Many algorithms share behaviors and you can copy-paste your prior implementations as a starting point.

## So, You're Stuck

Getting stuck, figuring out the cause, then solving the issue is part of the (fun) process. Expect it.

* Ask an LLM to critique your implementation.
* Ask an LLM to describe an aspect of the algorithm in more detail.
* Ask an LLM to generate a function for one aspect of the algorithm.
* Ask an LLM to describe the algorithm based on specific PDF paper you drop in.
* Ask an LLM to summarize a third-party implementation you drop in.

If you email me asking for help, I'll send you here.

## Resources

You're not alone. Countless developers, students, and academics have been where are now and some wrote about how they made progress.

Here are some ideas of where to search for more information on the algorithm you're implementing.

* Search [Google Scholar](https://scholar.google.com/).
* Search [Scholarpedia](http://www.scholarpedia.org/).
* Search [Wikipedia](https://www.wikipedia.org/).
	* Also, see: [Table of metaheuristics](https://en.wikipedia.org/wiki/Table_of_metaheuristics)
* Search [StackOverflow](https://stackoverflow.com/) and/or [CrossValidated](https://stats.stackexchange.com/).

## Books

You don't need a book to implement these algorithms. Nevertheless, reading a book of about descriptions can be a lot of fun for algorithm geeks like us.

Some books I like include:

* **[Clever Algorithms: Nature-Inspired Programming Recipes](https://amzn.to/3xEpjRT)**, Jason Brownlee, 2011.
	* [Free version](https://github.com/clever-algorithms/CleverAlgorithms), my book.
* **[Essentials of Metaheuristics](https://amzn.to/3Q23rpP)**, Sean Luke, 2013.
	* [Free version](https://cs.gmu.edu/~sean/book/metaheuristics/), just fantastic.
* **[Algorithms for Optimization](https://amzn.to/3VWRW6Q)**, Mykel J. Kochenderfer, Tim A. Wheeler, 2019.
	* Fantastic modern book that covers many optimization algorithms
* Evolutionary Computation Series
	* **[Evolutionary Computation 1: Basic Algorithms and Operators](https://amzn.to/3Jm4zAP)**, 2000.
	* **[Evolutionary Computation 2: Advanced Algorithms and Operations](https://amzn.to/49KL9QJ)**, 2000.
	* Together, these are the best introductory series on evolutionary computation.
* **[Computational Intelligence: An Introduction](https://amzn.to/44ixYWt)**, Andries P. Engelbrecht, 2007.
	* A great introduction to the field.

